"""
Alert system models for enhanced alerting with persistence.

Implements:
- Alert history with lifecycle tracking (created → acknowledged → resolved)
- Configurable alert rules (thresholds, conditions)
- Alert suppressions (time-based, by domain/type/severity)
"""

from sqlalchemy import Column, String, DateTime, Text, Float, Boolean, Integer, ForeignKey
from sqlalchemy.dialects.postgresql import UUID, JSONB
from sqlalchemy.orm import relationship
from datetime import datetime
import uuid
import enum
from app.database import Base


class AlertSeverity(str, enum.Enum):
    """Alert severity levels"""
    INFO = "info"
    WARNING = "warning"
    CRITICAL = "critical"


class AlertType(str, enum.Enum):
    """Types of alerts"""
    FAILURE_RATE = "failure_rate"      # High DMARC failure rate
    VOLUME_SPIKE = "volume_spike"      # Sudden increase in volume
    VOLUME_DROP = "volume_drop"        # Sudden decrease in volume
    NEW_SOURCE = "new_source"          # New source IP detected
    POLICY_VIOLATION = "policy_violation"  # Policy violations detected
    ANOMALY = "anomaly"                # ML-detected anomaly (Phase 4)


class AlertStatus(str, enum.Enum):
    """Alert lifecycle status"""
    CREATED = "created"              # Alert just created
    ACKNOWLEDGED = "acknowledged"    # Someone acknowledged the alert
    RESOLVED = "resolved"            # Alert resolved
    SUPPRESSED = "suppressed"        # Alert suppressed by rule


class AlertHistory(Base):
    """
    Persistent alert history with lifecycle tracking.

    Stores all alerts generated by the system with deduplication
    via fingerprinting (SHA256 hash of key attributes).
    """
    __tablename__ = "alert_history"

    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)

    # Alert identification - stored as strings, validated by Python enums
    alert_type = Column(String(50), nullable=False, index=True)
    severity = Column(String(20), nullable=False, index=True)

    # Deduplication fingerprint (SHA256 of: type + domain + metric + threshold)
    fingerprint = Column(String(64), nullable=False, index=True)

    # Alert content
    title = Column(String(500), nullable=False)
    message = Column(Text, nullable=False)
    domain = Column(String(255), nullable=True, index=True)

    # Alert metrics
    current_value = Column(Float, nullable=True)
    threshold_value = Column(Float, nullable=True)

    # Additional context (JSON)
    alert_metadata = Column(JSONB, nullable=True)

    # Lifecycle tracking
    status = Column(String(20), nullable=False, default=AlertStatus.CREATED.value, index=True)

    # Timestamps
    created_at = Column(DateTime, default=datetime.utcnow, nullable=False, index=True)
    acknowledged_at = Column(DateTime, nullable=True)
    acknowledged_by = Column(UUID(as_uuid=True), ForeignKey("users.id", ondelete="SET NULL"), nullable=True)
    resolved_at = Column(DateTime, nullable=True)
    resolved_by = Column(UUID(as_uuid=True), ForeignKey("users.id", ondelete="SET NULL"), nullable=True)

    # Notes/comments
    acknowledgement_note = Column(Text, nullable=True)
    resolution_note = Column(Text, nullable=True)

    # Notification tracking
    notification_sent = Column(Boolean, default=False, nullable=False)
    notification_sent_at = Column(DateTime, nullable=True)
    notification_channels = Column(JSONB, nullable=True)  # ["email", "teams", "slack"]

    # Cooldown tracking (prevent alert spam)
    cooldown_until = Column(DateTime, nullable=True)

    # Relationships
    acknowledged_by_user = relationship("User", foreign_keys=[acknowledged_by])
    resolved_by_user = relationship("User", foreign_keys=[resolved_by])

    def __repr__(self):
        return f"<AlertHistory(id={self.id}, type={self.alert_type}, severity={self.severity}, status={self.status})>"


class AlertRule(Base):
    """
    Configurable alert rules for threshold-based alerting.

    Allows UI-based configuration of alert thresholds instead of
    hardcoded environment variables.
    """
    __tablename__ = "alert_rules"

    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)

    # Rule identification
    name = Column(String(255), unique=True, nullable=False, index=True)
    description = Column(Text, nullable=True)
    alert_type = Column(String(50), nullable=False, index=True)

    # Rule configuration
    is_enabled = Column(Boolean, default=True, nullable=False, index=True)
    severity = Column(String(20), nullable=False)

    # Threshold conditions (JSON for flexibility)
    # Example: {"failure_rate": {"warning": 10.0, "critical": 25.0}}
    conditions = Column(JSONB, nullable=False)

    # Scope (apply to specific domains or all)
    domain_pattern = Column(String(255), nullable=True)  # NULL = all domains, "*.example.com" = specific

    # Cooldown (prevent alert spam)
    cooldown_minutes = Column(Integer, default=60, nullable=False)  # Default: 1 hour

    # Notification settings
    notify_email = Column(Boolean, default=True, nullable=False)
    notify_teams = Column(Boolean, default=True, nullable=False)
    notify_slack = Column(Boolean, default=False, nullable=False)
    notify_webhook = Column(Boolean, default=False, nullable=False)

    # Metadata
    created_at = Column(DateTime, default=datetime.utcnow, nullable=False)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow, nullable=False)
    created_by = Column(UUID(as_uuid=True), ForeignKey("users.id", ondelete="SET NULL"), nullable=True)

    # Relationships
    created_by_user = relationship("User", foreign_keys=[created_by])

    def __repr__(self):
        return f"<AlertRule(id={self.id}, name={self.name}, type={self.alert_type}, enabled={self.is_enabled})>"


class AlertSuppression(Base):
    """
    Alert suppression rules for temporary or permanent alert muting.

    Supports:
    - Time-based suppression (maintenance windows)
    - Domain-based suppression (ignore specific domains)
    - Type-based suppression (disable specific alert types)
    """
    __tablename__ = "alert_suppressions"

    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)

    # Suppression identification
    name = Column(String(255), nullable=False)
    description = Column(Text, nullable=True)
    is_active = Column(Boolean, default=True, nullable=False, index=True)

    # Suppression filters (all are optional, NULL = matches all)
    alert_type = Column(String(50), nullable=True, index=True)
    severity = Column(String(20), nullable=True, index=True)
    domain = Column(String(255), nullable=True, index=True)

    # Time-based suppression
    starts_at = Column(DateTime, nullable=True, index=True)
    ends_at = Column(DateTime, nullable=True, index=True)

    # Recurrence (for maintenance windows)
    # Example: {"type": "weekly", "days": ["saturday", "sunday"], "hours": [2, 3, 4]}
    recurrence = Column(JSONB, nullable=True)

    # Metadata
    created_at = Column(DateTime, default=datetime.utcnow, nullable=False)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow, nullable=False)
    created_by = Column(UUID(as_uuid=True), ForeignKey("users.id", ondelete="SET NULL"), nullable=True)

    # Relationships
    created_by_user = relationship("User", foreign_keys=[created_by])

    def __repr__(self):
        return f"<AlertSuppression(id={self.id}, name={self.name}, active={self.is_active})>"

    def is_suppressing_now(self) -> bool:
        """Check if this suppression is currently active"""
        if not self.is_active:
            return False

        now = datetime.utcnow()

        # Check time-based suppression
        if self.starts_at and self.ends_at:
            if not (self.starts_at <= now <= self.ends_at):
                return False
        elif self.starts_at:
            if now < self.starts_at:
                return False
        elif self.ends_at:
            if now > self.ends_at:
                return False

        return True

    def matches_alert(self, alert_type_val: str, severity_val: str, domain: str = None) -> bool:
        """Check if this suppression matches the given alert"""
        if not self.is_suppressing_now():
            return False

        # Check alert type
        if self.alert_type and self.alert_type != alert_type_val:
            return False

        # Check severity
        if self.severity and self.severity != severity_val:
            return False

        # Check domain (exact match or wildcard)
        if self.domain:
            if not domain:
                return False
            if self.domain != domain and not self._domain_matches_pattern(domain):
                return False

        return True

    def _domain_matches_pattern(self, domain: str) -> bool:
        """Check if domain matches suppression pattern"""
        if not self.domain:
            return True

        # Simple wildcard matching
        if self.domain.startswith("*."):
            pattern = self.domain[2:]  # Remove "*."
            return domain.endswith(pattern)

        return domain == self.domain
